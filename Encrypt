
local bot = getBot()
local inventory = getBot():getInventory()
local printed = getBot():getLog()

for index, botname in pairs(getBots()) do
    if bot.name:upper() == botname.name:upper() then
        pcallBot = index
    end
end

bot.collect_range = 3
bot.auto_reconnect = true
initialize = {}
local customizable = {
    tileX = 0,
    tileY = 0
}
local sleeping = delayexecute * 1000

local events = {
    nukeds = function(variant,netid)
        if variant:get(0):getString() == 'OnConsoleMessage' then
            if variant:get(1):getString():lower():find('inaccessible.') or variant:get(1):getString():lower():find('unknown reason.') then
                nuked = true
            end
            unlistenEvents()
        end
    end
}

itemFloat = function(id)
    return bot:getWorld().growscan:getObjects()[id] or 0
end

notifications = function(description)
    messageBox = MessageBox.new()
    messageBox.title = 'Caramoy Syndicate'
    messageBox.description = description
    messageBox:send()
end

textInfo = function(case,content)
    printed:append(content)
    clientContent('('..string.upper(bot.name)..') '..content)
    if case == 'stop' then
        notifications(string.upper(bot.name)..' : '..content)
        error(content)
    end
end

split = function(str,ptr)
    if not ptr then
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str,ptr) do
        table.insert(tbl,string)
    end
    return tbl
end

clientStatic = function()
    local statusMap = {
        [BotStatus.offline] = 'Offline',
        [BotStatus.account_banned] = 'Suspended',
        [BotStatus.location_banned] = 'Location Banned',
        [BotStatus.too_many_login] = 'Too Many Login',
        [BotStatus.maintenance] = 'Maintenance',
        [BotStatus.error_connecting] = 'Error Connecting',
        [BotStatus.http_block] = 'HTTP Block',
        [BotStatus.changing_subserver] = 'Changing Subserver',
        [BotStatus.mod_entered] = 'Mod Entered'
    }
    return (statusMap[bot.status] or 'Online')
end

worldStorage = function(case)
    local str = ''
    local data = {}
    if case == 'take' then
        data = storagetake
    elseif case == 'drop' then
        data = storagedrop
    elseif case == 'bots' or case == 'stat' or case == 'world' then
        data = getBots()
    end
    for i = 1, #data do
        if case == 'take' or case == 'drop' then
            local world = split(data[i], '[^|]+')[1]
            str = str .. '\n||' .. world .. '|| : ' .. (initialize[world] or '?')
        elseif case == 'bots' then
            str = str .. '\n||' .. string.sub(data[i].name, 1, 5) .. '||'
        elseif case == 'stat' then
            str = str .. '\n' .. clientStatic() .. ''
        elseif case == 'world' then
            str = str .. '\n' .. string.sub(data[i]:getWorld().name, 1, 5) .. ''
        end
    end
    return str
end

storageInfo = function()
	if linkbotinfo ~= 'x' then
        local webhook = Webhook.new(linkbotinfo)
        webhook.embed1.use = true
        webhook.embed1.color = math.random(111111,999999)
        webhook.embed1.thumbnail = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077262082068/Hnet.com-image.jpg?ex=661e7947&is=660c0447&hm=e692ab165629d6a84ca2661b5b4a75f97a23cfabb98983fda3270bc2be0e7474&'
        webhook.embed1:addField('','Updated : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60)),false)
        webhook.embed1:addField('Bot Name',worldStorage('bots'),true)
        webhook.embed1:addField('Bot Status',worldStorage('stat'),true)
        webhook.embed1:addField('Bot Current',worldStorage('world'),true)
        webhook.embed1:addField('Storage Take',worldStorage('take'),true)
        webhook.embed1:addField('Storage Drop',worldStorage('drop'),true)
        webhook.embed1.footer.icon_url = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077706543236/1712025730898.jpg?ex=661e7947&is=660c0447&hm=3be9efe2f0f23456f272149dc0844db884cee12f3b21199b35b2c1287c77a8f2&'
        webhook.embed1.footer.text = '[Lucifer Move]\nDeveloped By Caramoy and Made With Luv<3'
        webhook:edit(messageidbotinfo)
    end
end

clientContent = function(text)
    if webhookstatuslink ~= 'x'  then
        local webhook = Webhook.new(webhookstatuslink)
        webhook.content = '@everyone'
        webhook.embed1.use = true
        webhook.embed1:addField('',text,false)
        webhook.embed1.footer.text = 'Updated : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
        webhook:send()
    end
end

updateStatusInfo = function()
    textInfo('', 'status is ' .. clientStatic() .. ', Current: ' .. getWorld().name)
    storageInfo()
end

clientStatus = function()
    if bot.status ~= BotStatus.online then
        bot.auto_reconnect = false
        updateStatusInfo()
        while bot.status ~= BotStatus.online do
            bot:connect()
            sleep(1000)
            if bot.status == BotStatus.account_banned then
                textInfo('stop','status is '..clientStatic()..'')
            elseif bot.status == BotStatus.maintenance then
                textInfo('','Server is maintenance, Sleeping for '..delaymaintenance..' minutes')
                sleep(delaymaintenance * 60000)
            elseif bot.status ~= BotStatus.online then
                sleep(delayreconnect * 1000)
            elseif bot.status == BotStatus.online then
                sleep(5000)
                break
            end
        end
        updateStatusInfo()
        bot.auto_reconnect = true
    end
end

reconnect = function(world,id,x,y)
    if bot.status ~= BotStatus.online then
        clientStatus()
    end
    if not bot:isInWorld(world:upper()) then
        addEvent(Event.variantlist, events.nukeds)
        while not bot:isInWorld(world:upper()) and not nuked do
            bot:warp(world:upper())
            listenEvents(5)
            sleep(delaywarp * 1000)
        end
        removeEvents()
    end
    if bot:isInWorld(world:upper()) then
        if id ~= '' then
            while getTile(bot.x,bot.y).fg == 6 do
                bot:warp(world:upper(),id:upper())
                sleep(delaywarp * 1000)
            end
        end
    end
    if getTile(bot.x, bot.y).fg == 6 then
        if id ~= '' then
            while getTile(bot.x,bot.y).fg == 6 do
                bot:warp(world:upper(),id:upper())
                sleep(delaywarp * 1000)
            end
        end
    end
    if x and y then
        while bot.x ~= x or bot.y ~= y do
            bot:findPath(x,y)
            sleep(250)
        end
    end
end

warp = function(world,door)
    name = world
    if door ~= '' then
        name = name .. '|' ..door
    end
    if not bot:isInWorld(world:upper()) then
        local count = 0
        addEvent(Event.variantlist, events.nukeds)
        while not bot:isInWorld(world:upper()) and not nuked do
            clientStatus()
            bot:warp(name)
            listenEvents(5)
            sleep(delaywarp * 1000)
            count = count + 1
            if count == 15 then
                count = 0
                textInfo('',': Maybe hard warp?, disconnecting bot and sleeping for '..delayidiotserver..' minutes')
                bot:disconnect()
                sleep(delayidiotserver * 60000)
            end
        end
        removeEvents()
    end
    if bot:isInWorld(world:upper()) and door ~= '' then
        local stuck  = 0
        while getTile(bot.x,bot.y).fg == 6 and not wrong do
            clientStatus()
            bot:warp(name)
            sleep(delaywarp * 1000)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

storageDesc = function(types,text)
    while bot:isInWorld() and bot.status == BotStatus.online do
        bot:leaveWorld()
        sleep(5000)
    end
    if removingbot then
        removeBot()
        sleep(2000)
    end
    textInfo('stop','All '..types..' storage has '..text..', Script terminated.')
end

checkPosObject = function(worlds, doors)
    local count = 0
    warp(worlds, doors)
    if not nuked and not wrong then
        for _, tile in pairs(bot:getWorld():getTiles()) do
            if tile.fg == posId or tile.bg == posId then
                count = count + 1
            end
        end
    end
    return count
end

shuffle = function(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
    return tbl
end

dropNumeric = shuffle(storagedrop)
takeNumeric = shuffle(storagetake)

forSeparated = function(x,y)
    local stack = 0, 0
    for _,obj in pairs(bot:getWorld():getObjects()) do
        if math.floor(obj.x / 32) == x and math.floor(obj.y / 32) == y then
            stack = stack + 1
        end
    end
    if stack >= 1 then
        return true
    end
    return false
end

checkStorage = function(tbl, types, text)
    if #tbl == 0 then
        storageDesc(types, text)
    end
end

dropItem = function()
    printed:append('Drop Items')
    for i = #dropNumeric, 1, -1 do
        parts = split(dropNumeric[i], '[^|]+')
        world, door = parts[1], parts[2]
        warp(world, door)
        if nuked then
            nuked = false
            initialize[world] = 'Nuked'
            customizable.tileX = 0
            customizable.tileY = 0
            textInfo('', 'storage drop : ' .. world .. ' is NUKED, Skipped world')
            table.remove(dropNumeric, i)
            checkStorage(dropNumeric, 'drop', 'reached limit')
        end
        if wrong then
            wrong = false
            initialize[world] = 'Wrong'
            customizable.tileX = 0
            customizable.tileY = 0
            textInfo('', 'storage drop : ' .. world .. ' is Wrong, Skipped world')
            table.remove(dropNumeric, i)
            checkStorage(dropNumeric, 'drop', 'reached limit')
        end
        sleep(math.random(1, 1000))
        storageInfo()
        if itemFloat(itemId[1]) < limit then
            if checkPosObject(world, door) == 0 then
                textInfo('stop', 'Cant find to position, check ur pos id configs')
            end
            for y, pack in pairs(itemId) do
                for i, tile in pairs(bot:getWorld():getTiles()) do
                    if tile.fg == posId or tile.bg == posId then
                        ::back::
                        if separated then
                            if #itemId == 1 then
                                bot:findPath(tile.x + customizable.tileX, tile.y - customizable.tileY)
                                sleep(math.random(100,300))
                                reconnect(world, door, tile.x + customizable.tileX, tile.y - customizable.tileY)
                                if tile.x + customizable.tileX >= 98 then
                                    customizable.tileY = customizable.tileY + 1
                                    customizable.tileX = 0
                                    goto back
                                end
                                if forSeparated(bot.x - 1, bot.y) then
                                    customizable.tileX = customizable.tileX + 1
                                    sleep(math.random(100,300))
                                    goto back
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(true)
                                    sleep(math.random(100,300))
                                    bot:drop(pack, 200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world, door, tile.x + customizable.tileX, tile.y - customizable.tileY)
                                end
                            else
                                bot:findPath(tile.x + (y - 1), tile.y - customizable.tileY)
                                sleep(math.random(100,300))
                                reconnect(world, door, tile.x + (y - 1), tile.y - customizable.tileY)
                                if tile.y - customizable.tileY == 0 then
                                    initialize[world] = '' .. itemFloat(itemId[1]) .. 'x [Drop Failed]'
                                    while bot:isInWorld() and bot.status == BotStatus.online do
                                        bot:leaveWorld()
                                        sleep(5000)
                                    end
                                    textInfo('stop', 'Cant drop cuz bot at coordinate y = 0, check ur world! script terminated')
                                end
                                if forSeparated(bot.x - 1, bot.y) then
                                    customizable.tileY = customizable.tileY + 1
                                    sleep(math.random(100,300))
                                    goto back
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(true)
                                    sleep(math.random(100,300))
                                    bot:drop(pack, 200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world, door, tile.x + (y - 1), tile.y - customizable.tileY)
                                end
                            end
                        else
                            bot:findPath(tile.x + customizable.tileX, tile.y - customizable.tileY)
                            sleep(100)
                            local count = 0
                            reconnect(world, door, tile.x + customizable.tileX, tile.y - customizable.tileY)
                            if tile.x + customizable.tileX >= 98 then
                                customizable.tileY = customizable.tileY + 1
                                customizable.tileX = 0
                                goto back
                            end
                            while inventory:getItemCount(pack) > 0 do
                                bot:setDirection(true)
                                sleep(100)
                                bot:drop(pack, 200)
                                sleep(delaydrop * 1000)
                                reconnect(world, door, tile.x + customizable.tileX, tile.y - customizable.tileY)
                                count = count + 1
                                if count >= 2 then
                                    count = 0
                                    customizable.tileX = customizable.tileX + 1
                                    goto back
                                end
                            end
                        end
                    end
                    if inventory:getItemCount(pack) == 0 then
                        break
                    end
                end
            end
            sleep(100)
            break
        else
            initialize[world] = '' .. itemFloat(itemId[1]) .. 'x [LIMIT]'
            textInfo('', 'Storage drop : ' .. world .. ' has reached limit, Skipped world')
            table.remove(dropNumeric, i)
            customizable.tileX = 0
            customizable.tileY = 0
            checkStorage(dropNumeric, 'drop', 'reached limit')
        end
    end
    initialize[world] = '' .. itemFloat(itemId[1]) .. 'x'
end

takeItem = function()
    ::back::
    printed:append('Take Item')
    takeNumeric = shuffle(takeNumeric)
    for i = #takeNumeric, 1, -1 do
        parts = split(takeNumeric[i], '[^|]+')
        world, door = parts[1], parts[2]
        warp(world,door)
        bot.auto_collect = true
        if nuked then
            initialize[world] = 'Nuked'
            nuked = false
            textInfo('','Storage take : '..world..' Nuked, Skipped world.')
            table.remove(takeNumeric,i)
            checkStorage(takeNumeric, 'take', 'empty')
        end
        if wrong then
            initialize[world] = 'Wrong'
            nuked = false
            textInfo('','Storage take : '..world..' Wrong, Skipped world.')
            table.remove(takeNumeric,i)
            checkStorage(takeNumeric, 'take', 'empty')
        end
        sleep(math.random(1,1000))
        storageInfo()
        if itemFloat(itemId[1]) < minimumFloat then
            initialize[world] = ''..itemFloat(itemId[1])..'x [EMPTY]'
            if not looping then
                textInfo('','Storage take : '..world..' are empty, Skipped world')
                table.remove(takeNumeric,i)
                checkStorage(takeNumeric, 'take', 'empty')
            else
                sleep(delaylooping*1000)
                goto back
            end
        else
            for _, pack in pairs(itemId) do
                local count = 0
                while inventory:getItemCount(pack) < 200 do
                    for _, obj in pairs(bot:getWorld():getObjects()) do
                        if obj.id == pack and (#bot:getPath(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32) > 0)) then
                            bot:findPath(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                            sleep(100)
                            reconnect(world,door,math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                        end
                        if inventory:getItemCount(pack) >= 200 then
                            break
                        end
                    end
                    count = count + 1
                    if count == 50 then
                        count = 0
                        if not looping then
                            table.remove(takeNumeric,i)
                            textInfo('','No more items at '..world..', world skipped')
                            checkStorage(takeNumeric, 'take', 'empty')
                        end
                        goto back
                    end
                end
            end
            sleep(100)
            break
        end
    end
    bot.auto_collect = false
    initialize[world] = ''..itemFloat(itemId[1])..'x'
end

if Information == 'Script Move WTW made by Caramoy Syndicate, Link Server : https://discord.com/invite/fTTKW8vvuq' and scriptVersion == 'final_version[0.1]' then
    sleep(pcallBot * sleeping)
    while true do
        takeItem()
        dropItem()
    end
else
    textInfo('stop','Script Move WTW made by Caramoy Syndicate, Link Server : https://discord.com/invite/fTTKW8vvuq. Reseller IDIOT !!')
end
