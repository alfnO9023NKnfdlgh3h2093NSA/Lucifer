
local bot = getBot()
local inventory = getBot():getInventory()
local printed = getBot():getLog()

for index, botname in pairs(getBots()) do
    if bot.name:upper() == botname.name:upper() then
        pcallBot = index
    end
end

bot.auto_reconnect = true
initialize = {}
local customizable = {
    tileX = 0,
    tileY = 0
}
local sleeping = delayexecute * 1000

local events = {
    nukeds = function(variant,netid)
        if variant:get(0):getString() == 'OnConsoleMessage' then
            if variant:get(1):getString():lower():find('inaccessible.') or variant:get(1):getString():lower():find('unknown reason.') then
                nuked = true
            end
            unlistenEvents()
        end
    end
}

itemFloat = function(id)
    return bot:getWorld().growscan:getObjects()[id] or 0
end

checkingForItems = function()
    for _, list in pairs(itemId) do
        if inventory:getItemCount(list) >= 200 then
            return true
        end
    end
    return false
end

notifications = function(description)
    messageBox = MessageBox.new()
    messageBox.title = 'Caramoy Syndicate'
    messageBox.description = description
    messageBox:send()
end

textInfo = function(case,content)
    printed:append(content)
    clientContent('('..string.upper(bot.name)..') '..content)
    if case == 'stop' then
        notifications(string.upper(bot.name)..' : '..content)
        error(content)
    end
end

split = function(str,ptr)
    if not ptr then
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str,ptr) do
        table.insert(tbl,string)
    end
    return tbl
end

clientStatic = function()
    local desc = bot.status
    if desc == BotStatus.offline then
        return 'Offline'
    elseif desc == BotStatus.account_banned then
        return 'Suspended'
    elseif desc == BotStatus.location_banned then
        return 'Location Banned'
    elseif desc == BotStatus.too_many_login then
        return 'Too Many Login'
    elseif desc == BotStatus.maintenance then
        return 'Maintenance'
    elseif desc == BotStatus.error_connecting then
        return 'Error Connecting'
    elseif desc == BotStatus.http_block then
        return 'HTTP Block'
    elseif desc == BotStatus.changing_subserver then
        return 'Changing Subserver'
    elseif desc == BotStatus.mod_entered then
        return 'Mod Entered'
    else
        return 'Online'
    end
end

storageInfo = function()
    local worldStorage = function(case)
        local str = ''
        if case == 'take' then
            for i = 1, #storagetake do
                str = str..'\n||'..split(storagetake[i],'[^|]+')[1]..'|| : '..(initialize[split(storagetake[i],'[^|]+')[1]] or '?')..''
            end
        elseif case == 'drop' then
            for i = 1, #storagedrop do
                str = str..'\n||'..split(storagedrop[i],'[^|]+')[1]..'|| : '..(initialize[split(storagedrop[i],'[^|]+')[1]] or '?')..''
            end
        elseif case == 'bots' then
            for i = 1, #getBots() do
                str = str..'\n||'..string.sub(getBots()[i].name,1,5)..'||'
            end
        elseif case == 'stat' then
            for i = 1, #getBots() do
                str = str..'\n||'..clientStatic()..'||'
            end
        elseif case == 'world' then
            for i = 1, #getBots() do
                str = str..'\n||'..string.sub(getBots()[i]:getWorld().name,1,5)..'||'
            end
        end
        return str
    end
	if linkbotinfo ~= 'x' then
        local webhook = Webhook.new(linkbotinfo)
        webhook.embed1.use = true
        webhook.embed1.color = math.random(111111,999999)
        webhook.embed1.thumbnail = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077262082068/Hnet.com-image.jpg?ex=661e7947&is=660c0447&hm=e692ab165629d6a84ca2661b5b4a75f97a23cfabb98983fda3270bc2be0e7474&'
        webhook.embed1:addField('','Updated : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60)),false)
        webhook.embed1:addField('Bot Name',worldStorage('bots'),true)
        webhook.embed1:addField('Bot Status',worldStorage('stat'),true)
        webhook.embed1:addField('Bot Current',worldStorage('world'),true)
        webhook.embed1:addField('Storage Take',worldStorage('take'),true)
        webhook.embed1:addField('Storage Drop',worldStorage('drop'),true)
        webhook.embed1.footer.icon_url = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077706543236/1712025730898.jpg?ex=661e7947&is=660c0447&hm=3be9efe2f0f23456f272149dc0844db884cee12f3b21199b35b2c1287c77a8f2&'
        webhook.embed1.footer.text = '[Lucifer Move]\nDeveloped By Caramoy and Made With Luv<3'
        webhook:edit(messageidbotinfo)
    end
end

clientContent = function(text)
    if webhookstatuslink ~= 'x'  then
        local webhook = Webhook.new(webhookstatuslink)
        webhook.content = '@everyone'
        webhook.embed1.use = true
        webhook.embed1:addField('',text,false)
        webhook.embed1.footer.text = 'Updated : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
        webhook:send()
    end
end

clientStatus = function()
    if bot.status ~= BotStatus.online then
        bot.auto_reconnect = false
        textInfo('','status is '..clientStatic()..', Current : '..getWorld().name..'')
        storageInfo()
        while bot.status ~= BotStatus.online do
            bot:connect()
            sleep(5000)
            if bot.status == BotStatus.account_banned then
                textInfo('stop','status is '..clientStatic()..'')
            elseif bot.status == BotStatus.maintenance then
                textInfo('','Server is maintenance, Sleeping for '..delaymaintenance..' minutes')
                sleep(delaymaintenance * 60000)
            elseif bot.status ~= BotStatus.online then
                sleep(delayreconnect * 1000)
            elseif bot.status == BotStatus.online then
                sleep(5000)
                break
            end
        end
        textInfo('','status is '..clientStatic()..', Current : '..getWorld().name..'')
        bot.auto_reconnect = true
    end
end

reconnect = function(world,id,x,y)
    if bot.status ~= BotStatus.online then
        clientStatus()
    end
    if not bot:isInWorld(world:upper()) then
        addEvent(Event.variantlist, events.nukeds)
        while not bot:isInWorld(world:upper()) and not nuked do
            bot:warp(world:upper())
            listenEvents(5)
            sleep(delaywarp * 1000)
        end
        removeEvents()
    end
    if bot:isInWorld(world:upper()) then
        if id ~= '' then
            while getTile(bot.x,bot.y).fg == 6 do
                bot:warp(world:upper(),id:upper())
                sleep(delaywarp * 1000)
            end
        end
        if x and y then
            while bot.x ~= x or bot.y ~= y do
                bot:findPath(x,y)
                sleep(250)
            end
        end
    end
end

warp = function(world,door)
    name = world
    if door ~= '' then
        name = name .. '|' ..door
    end
    if not bot:isInWorld(world:upper()) then
        count = 0
        addEvent(Event.variantlist, events.nukeds)
        while not bot:isInWorld(world:upper()) and not nuked do
            clientStatus()
            bot:warp(name)
            listenEvents(5)
            sleep(delaywarp * 1000)
            count = count + 1
            if count == 15 then
                count = 0
                textInfo('',': Maybe hard warp?, disconnecting bot and sleeping for '..delayidiotserver..' minutes')
                bot:disconnect()
                sleep(delayidiotserver * 60000)
            end
        end
        removeEvents()
    end
    if bot:isInWorld(world:upper()) and door ~= '' then
        local stuck  = 0
        while getTile(bot.x,bot.y).fg == 6 and not wrong do
            clientStatus()
            bot:warp(name)
            sleep(delaywarp * 1000)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

storageDesc = function(text,text2)
    while bot:isInWorld() and bot.status == BotStatus.online do
        bot:leaveWorld()
        sleep(5000)
    end
    if removingbot then
        removeBot()
        sleep(2000)
    end
    textInfo('stop','All '..text..' storage has '..text2..', Script terminated.')
end

checkPosObject = function()
    local count = 0
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg == posId or tile.bg == posId then
            count = count + 1
        end
    end
    return count
end

forSeparated = function(x,y)
    local stack = 0, 0
    for _,obj in pairs(getObjects()) do
        if math.floor(obj.x / 32) == x and math.floor(obj.y / 32) == y then
            stack = stack + 1
        end
    end
    if stack >= 1 then
        return true
    end
    return false
end

shuffle = function(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
    return tbl
end
dropNumeric = shuffle(storagedrop)
takeNumeric = shuffle(storagetake)

dropItem = function()
    ::backs::
    printed:append('Drop Items')
    dropNumeric = shuffle(dropNumeric)
    for i = #dropNumeric, 1, -1 do
        parts = split(dropNumeric[i], '[^|]+')
        world, door = parts[1], parts[2]
        warp(world,door)
        if not nuked then
            if not wrong then
                storageInfo()
                ::loops::
                if itemFloat(itemId[1]) >= limit then
                    initialize[world] = ''..itemFloat(itemId[1])..'x [LIMIT]'
                    textInfo('','Storage drop : '..world..' has reached limit, Skipped world')
                    table.remove(dropNumeric,i)
                    customizable.tileX = 0
                    customizable.tileY = 0
                    if #dropNumeric == 0 then
                        storageDesc('drop','reached limit')
                    end
                else
                    if checkPosObject() == 0 then
                        textInfo('stop','Cant find to position, check ur pos id configs')
                    end
                    for y, pack in pairs(itemId) do
                        for i, tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == posId or tile.bg == posId then
                                if separated then
                                    if #itemId == 1 then
                                        ::back::
                                        bot:findPath(tile.x + (customizable.tileX),tile.y - (customizable.tileY))
                                        sleep(100)
                                        reconnect(world,door,tile.x + (customizable.tileX),tile.y - (customizable.tileY))
                                        if tile.x + (customizable.tileX) >= 98 then
                                            initialize[world] = ''..itemFloat(itemId[1])..'x [LIMIT]'
                                            customizable.tileY = customizable.tileY + 1
                                            customizable.tileX = 0
                                            break
                                        end
                                        if forSeparated(bot.x -1, bot.y) then
                                            customizable.tileX = customizable.tileX + 1
                                            goto back
                                        end
                                        if itemFloat(itemId[1]) >= limit then
                                            goto loops
                                        else
                                            while inventory:getItemCount(pack) > 0 do
                                                bot:setDirection(true)
                                                sleep(500)
                                                bot:drop(pack,200)
                                                sleep(delaydrop * 1000)
                                                reconnect(world,door,tile.x + (customizable.tileX),tile.y - (customizable.tileY))
                                            end
                                        end
                                    else
                                        ::back::
                                        bot:findPath(tile.x + (y-1),tile.y - (customizable.tileY))
                                        sleep(100)
                                        reconnect(world,door,tile.x + (y-1),tile.y - (customizable.tileY))
                                        if tile.y - (customizable.tileY) == 0 then
                                            initialize[world] = ''..itemFloat(itemId[1])..'x [Drop Failed]'
                                            textInfo('','Cant drop cuz bot at coordinate y = 0, skipped world')
                                            table.remove(dropNumeric,i)
                                            if #dropNumeric == 0 then
                                                storageDesc('drop','reached limit')
                                            end
                                            goto backs
                                        end
                                        if forSeparated(bot.x -1, bot.y) then
                                            customizable.tileY = customizable.tileY + 1
                                            goto back
                                        end
                                        if itemFloat(itemId[1]) >= limit then
                                            goto loops
                                        else 
                                            while inventory:getItemCount(pack) > 0 do
                                                bot:setDirection(true)
                                                sleep(500)
                                                bot:drop(pack,200)
                                                sleep(delaydrop * 1000)
                                                reconnect(world,door,tile.x + (y-1),tile.y - (customizable.tileY))
                                            end
                                        end
                                    end
                                else
                                    ::back::
                                    bot:findPath(tile.x + (customizable.tileX),tile.y - (customizable.tileY))
                                    sleep(100)
                                    reconnect(world,door,tile.x + (customizable.tileX),tile.y - (customizable.tileY))
                                    if tile.x + (customizable.tileX) >= 98 then
                                        customizable.tileY = customizable.tileY + 1
                                        customizable.tileX = 0
                                        goto back
                                    end
                                    if itemFloat(itemId[1]) >= limit then
                                        goto loops
                                    else
                                        count = 0
                                        while inventory:getItemCount(pack) > 0 do
                                            bot:setDirection(true)
                                            sleep(250)
                                            bot:drop(pack,200)
                                            sleep(delaydrop * 1000)
                                            reconnect(world,door,tile.x + (customizable.tileX),tile.y - (customizable.tileY))
                                            count = count + 1
                                            if count >= 2 then
                                                count = 0
                                                customizable.tileX = customizable.tileX + 1
                                                goto back
                                            end
                                        end
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'Wrong Door'
                wrong = false
                textInfo('','Storage drop : '..world..' is wrong door, Skipped world')
                table.remove(dropNumeric,i)
                customizable.tileX = 0
                customizable.tileY = 0
                if #dropNumeric == 0 then
                    storageDesc('drop','reached limit')
                end
            end
        else
            initialize[world] = 'Nuked'
            nuked = false
            textInfo('','storage drop : '..world..' is NUKED, Skipped world')
            table.remove(dropNumeric,i)
            customizable.tileX = 0
            customizable.tileY = 0
            if #dropNumeric == 0 then
                storageDesc('drop','reached limit')
            end
        end
    end
    initialize[world] = ''..itemFloat(itemId[1])..'x'
end

takeItem = function()
    if not checkingForItems() then
        printed:append('Take Item')
        ::loops::
        takeNumeric = shuffle(takeNumeric)
        for i = #takeNumeric, 1, -1 do
            parts = split(takeNumeric[i], '[^|]+')
            world, door = parts[1], parts[2]
            warp(world,door)
            if not nuked then
                if not wrong then
                    storageInfo()
                    if itemFloat(itemId[1]) == 0 then
                        initialize[world] = ''..itemFloat(itemId[1])..'x [EMPTY]'
                        if not looping then
                            textInfo('','Storage take : '..world..' are empty, Skipped world')
                            table.remove(takeNumeric,i)
                            if #takeNumeric == 0 then
                                storageDesc('take','empty')
                            end
                        else
                            sleep(delaylooping*1000)
                            goto loops
                        end
                    else
                        for _, pack in pairs(itemId) do
                            count = 0
                            while inventory:getItemCount(pack) < 200 do
                                for _, obj in pairs(bot:getWorld():getObjects()) do
                                    if obj.id == pack and (#bot:getPath((obj.x + 10) // 32, (obj.y + 10) // 32) > 0) then
                                        bot:findPath(math.floor(obj.x + 10) // 32, math.floor(obj.y + 10) // 32)
                                        sleep(1000)
                                        bot:collect(3)
                                        sleep(1000)
                                        reconnect(world,door,math.floor(obj.x + 10) // 32, math.floor(obj.y + 10) // 32)
                                        break
                                    end
                                end
                                count = count + 1
                                sleep(300)
                                if count == 5 then
                                    count = 0
                                    break
                                end
                            end
                        end
                        sleep(100)
                        break
                    end
                else
                    initialize[world] = 'Wrong Door'
                    wrong = false
                    textInfo('','Storage take : '..world..' is wrong door id, Skipped world')
                    table.remove(takeNumeric,i)
                    if #takeNumeric == 0 then
                        storageDesc('take','empty')
                    end
                end
            else
                initialize[world] = 'Nuked'
                nuked = false
                textInfo('','Storage take : '..world..' NUKED, Skipped world.')
                table.remove(takeNumeric,i)
                if #takeNumeric == 0 then
                    storageDesc('take','empty')
                end
            end
        end
        initialize[world] = ''..itemFloat(itemId[1])..'x'
    end
end

if Information == 'Script Move WTW made by Caramoy Syndicate, Link Server : https://discord.com/invite/fTTKW8vvuq' and scriptVersion == 'final_version[0.1]' then
    sleep(pcallBot * sleeping)
    while true do
        takeItem()
        dropItem()
    end
else
    textInfo('stop','Script Move WTW made by Caramoy Syndicate, Link Server : https://discord.com/invite/fTTKW8vvuq. Reseller IDIOT !!')
end
